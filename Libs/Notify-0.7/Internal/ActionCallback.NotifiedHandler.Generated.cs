
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Notify07.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY

/// <summary>
/// Notified Handler for ActionCallback. A notified annotation indicates the closure should
/// be kept alive until it is manually removed by the user. This removal is indicated by a
/// destroy_notify event, emitted by the relevant library. Pass <c>DestroyNotify</c> in place of a
/// destroy_notify callback parameter. 
/// </summary>

public class ActionCallbackNotifiedHandler
{
    public Notify07.Internal.ActionCallback? NativeCallback;
    public GLib.Internal.DestroyNotify? DestroyNotify;

    private Notify07.ActionCallback? managedCallback;
    private GCHandle gch;

    public ActionCallbackNotifiedHandler(Notify07.ActionCallback? managed)
    {
        DestroyNotify = DestroyCallback;
        managedCallback = managed;
        
        if (managedCallback is null)
        {
            NativeCallback = null;
            DestroyNotify = null;
        }
        else
        {
            gch = GCHandle.Alloc(this);

            
NativeCallback = (IntPtr notification, GLib.Internal.NonNullableUtf8StringHandle action, IntPtr userData) => {
    var notificationNative = (Notify07.Notification) GObject.Internal.InstanceWrapper.WrapHandle<Notify07.Notification>(notification, false);
var actionNative = action.ConvertToString();

    managedCallback(notificationNative, actionNative);

    
    
    
};
        }
    }

    private void DestroyCallback(IntPtr userData)
    {
        gch.Free();
    }
}