
using System;
using System.Linq;
using GObject;
using System.Runtime.InteropServices;

#nullable enable

namespace Secret;

// AUTOGENERATED FILE - DO NOT MODIFY

public partial class Item : GObject.GTypeProvider, GObject.InstanceFactory
{

    public static new GObject.Type GetGType()
    {
        return Secret.Internal.Item.GetGType();
    }

    static object GObject.InstanceFactory.Create(IntPtr handle, bool ownsHandle)
    {
        return CreateIntern(handle, ownsHandle);
    }

    private static Item CreateIntern(IntPtr handle, bool ownsHandle)
    {
        return new Item(new Secret.Internal.ItemHandle(handle, ownsHandle));
    }

    


public static Secret.Item CreateFinish(Gio.AsyncResult result)
{
    
    var resultCreateFinish = Secret.Internal.Item.CreateFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Item) GObject.Internal.InstanceWrapper.WrapHandle<Secret.Item>(resultCreateFinish, true);
}


public static Secret.Item CreateSync(Secret.Collection collection, Secret.Schema? schema, GLib.HashTable attributes, string label, Secret.Value value, Secret.ItemCreateFlags flags, Gio.Cancellable? cancellable)
{
    using var labelNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(label);
    var resultCreateSync = Secret.Internal.Item.CreateSync(collection.Handle.DangerousGetHandle(), (Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, labelNative, value.Handle, flags, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Item) GObject.Internal.InstanceWrapper.WrapHandle<Secret.Item>(resultCreateSync, true);
}



public static bool LoadSecretsFinish(Gio.AsyncResult result)
{
    
    var resultLoadSecretsFinish = Secret.Internal.Item.LoadSecretsFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultLoadSecretsFinish;
}


public static bool LoadSecretsSync(GLib.List items, Gio.Cancellable? cancellable)
{
    
    var resultLoadSecretsSync = Secret.Internal.Item.LoadSecretsSync(items.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultLoadSecretsSync;
}

}