
using System;
using System.Linq;
using GObject;
using System.Runtime.InteropServices;

#nullable enable

namespace Secret;

// AUTOGENERATED FILE - DO NOT MODIFY

public partial class Collection : GObject.GTypeProvider, GObject.InstanceFactory
{

    public static new GObject.Type GetGType()
    {
        return Secret.Internal.Collection.GetGType();
    }

    static object GObject.InstanceFactory.Create(IntPtr handle, bool ownsHandle)
    {
        return CreateIntern(handle, ownsHandle);
    }

    private static Collection CreateIntern(IntPtr handle, bool ownsHandle)
    {
        return new Collection(new Secret.Internal.CollectionHandle(handle, ownsHandle));
    }

    


public static Secret.Collection CreateFinish(Gio.AsyncResult result)
{
    
    var resultCreateFinish = Secret.Internal.Collection.CreateFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Collection) GObject.Internal.InstanceWrapper.WrapHandle<Secret.Collection>(resultCreateFinish, true);
}


public static Secret.Collection CreateSync(Secret.Service? service, string label, string? alias, Secret.CollectionCreateFlags flags, Gio.Cancellable? cancellable)
{
    using var labelNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(label);
using var aliasNative = GLib.Internal.NullableUtf8StringOwnedHandle.Create(alias);
    var resultCreateSync = Secret.Internal.Collection.CreateSync(service?.Handle.DangerousGetHandle() ?? IntPtr.Zero, labelNative, aliasNative, flags, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Collection) GObject.Internal.InstanceWrapper.WrapHandle<Secret.Collection>(resultCreateSync, true);
}



public static Secret.Collection? ForAliasFinish(Gio.AsyncResult result)
{
    
    var resultForAliasFinish = Secret.Internal.Collection.ForAliasFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Collection?) GObject.Internal.InstanceWrapper.WrapNullableHandle<Secret.Collection>(resultForAliasFinish, true);
}


public static Secret.Collection? ForAliasSync(Secret.Service? service, string alias, Secret.CollectionFlags flags, Gio.Cancellable? cancellable)
{
    using var aliasNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(alias);
    var resultForAliasSync = Secret.Internal.Collection.ForAliasSync(service?.Handle.DangerousGetHandle() ?? IntPtr.Zero, aliasNative, flags, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Collection?) GObject.Internal.InstanceWrapper.WrapNullableHandle<Secret.Collection>(resultForAliasSync, true);
}

}