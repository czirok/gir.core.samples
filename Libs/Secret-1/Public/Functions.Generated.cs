
using System;
using System.Linq;
using System.Runtime.InteropServices;

#nullable enable

namespace Secret;

// AUTOGENERATED FILE - DO NOT MODIFY

public static partial class Functions
{
    


public static GLib.HashTable AttributesBuildv(Secret.Schema schema, IntPtr va)
{
    
    var resultAttributesBuildv = Secret.Internal.Functions.AttributesBuildv(schema.Handle, va);

    
    
    return new GLib.HashTable(resultAttributesBuildv);
}

[Version("0.21.2")]
public static bool AttributesValidate(Secret.Schema schema, GLib.HashTable attributes)
{
    
    var resultAttributesValidate = Secret.Internal.Functions.AttributesValidate(schema.Handle, attributes.Handle, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultAttributesValidate;
}


[Version("0.19.0")]
public static Secret.Backend BackendGetFinish(Gio.AsyncResult result)
{
    
    var resultBackendGetFinish = Secret.Internal.Functions.BackendGetFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return (Secret.Backend) GObject.Internal.InstanceWrapper.WrapHandle<Secret.BackendHelper>(resultBackendGetFinish, true);
}


public static GLib.Quark ErrorGetQuark()
{
    
    var resultErrorGetQuark = Secret.Internal.Functions.ErrorGetQuark();

    
    
    return resultErrorGetQuark;
}

[Version("0.18.6")]
public static Secret.Schema GetSchema(Secret.SchemaType type)
{
    
    var resultGetSchema = Secret.Internal.Functions.GetSchema(type);

    
    
    return new Secret.Schema(resultGetSchema.OwnedCopy());
}



public static bool PasswordClearFinish(Gio.AsyncResult result)
{
    
    var resultPasswordClearFinish = Secret.Internal.Functions.PasswordClearFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordClearFinish;
}




public static bool PasswordClearSync(Secret.Schema? schema, GLib.HashTable attributes, Gio.Cancellable? cancellable)
{
    
    var resultPasswordClearSync = Secret.Internal.Functions.PasswordClearSync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordClearSync;
}


public static void PasswordFree(string? password)
{
    using var passwordNative = GLib.Internal.NullableUtf8StringOwnedHandle.Create(password);
    Secret.Internal.Functions.PasswordFree(passwordNative);

    
    
    
}


[Version("0.19.0")]
public static Secret.Value PasswordLookupBinaryFinish(Gio.AsyncResult result)
{
    
    var resultPasswordLookupBinaryFinish = Secret.Internal.Functions.PasswordLookupBinaryFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return new Secret.Value(resultPasswordLookupBinaryFinish);
}



public static string PasswordLookupFinish(Gio.AsyncResult result)
{
    
    var resultPasswordLookupFinish = Secret.Internal.Functions.PasswordLookupFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordLookupFinish.ConvertToString();
}


public static string PasswordLookupNonpageableFinish(Gio.AsyncResult result)
{
    
    var resultPasswordLookupNonpageableFinish = Secret.Internal.Functions.PasswordLookupNonpageableFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordLookupNonpageableFinish.ConvertToString();
}




[Version("0.19.0")]
public static Secret.Value PasswordLookupvBinarySync(Secret.Schema? schema, GLib.HashTable attributes, Gio.Cancellable? cancellable)
{
    
    var resultPasswordLookupvBinarySync = Secret.Internal.Functions.PasswordLookupvBinarySync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return new Secret.Value(resultPasswordLookupvBinarySync);
}


public static string PasswordLookupvNonpageableSync(Secret.Schema? schema, GLib.HashTable attributes, Gio.Cancellable? cancellable)
{
    
    var resultPasswordLookupvNonpageableSync = Secret.Internal.Functions.PasswordLookupvNonpageableSync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordLookupvNonpageableSync.ConvertToString();
}


public static string PasswordLookupSync(Secret.Schema? schema, GLib.HashTable attributes, Gio.Cancellable? cancellable)
{
    
    var resultPasswordLookupSync = Secret.Internal.Functions.PasswordLookupSync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordLookupSync.ConvertToString();
}


[Version("0.19.0")]
public static GLib.List PasswordSearchFinish(Gio.AsyncResult result)
{
    
    var resultPasswordSearchFinish = Secret.Internal.Functions.PasswordSearchFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return new GLib.List(resultPasswordSearchFinish);
}



[Version("0.19.0")]
public static GLib.List PasswordSearchSync(Secret.Schema? schema, GLib.HashTable attributes, Secret.SearchFlags flags, Gio.Cancellable? cancellable)
{
    
    var resultPasswordSearchSync = Secret.Internal.Functions.PasswordSearchSync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, flags, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return new GLib.List(resultPasswordSearchSync);
}





public static bool PasswordStoreFinish(Gio.AsyncResult result)
{
    
    var resultPasswordStoreFinish = Secret.Internal.Functions.PasswordStoreFinish(((GObject.Object)result).Handle.DangerousGetHandle(), out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordStoreFinish;
}




[Version("0.19.0")]
public static bool PasswordStoreBinarySync(Secret.Schema? schema, GLib.HashTable attributes, string? collection, string label, Secret.Value value, Gio.Cancellable? cancellable)
{
    using var collectionNative = GLib.Internal.NullableUtf8StringOwnedHandle.Create(collection);
using var labelNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(label);
    var resultPasswordStoreBinarySync = Secret.Internal.Functions.PasswordStoreBinarySync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, collectionNative, labelNative, value.Handle, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordStoreBinarySync;
}


public static bool PasswordStoreSync(Secret.Schema? schema, GLib.HashTable attributes, string? collection, string label, string password, Gio.Cancellable? cancellable)
{
    using var collectionNative = GLib.Internal.NullableUtf8StringOwnedHandle.Create(collection);
using var labelNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(label);
using var passwordNative = GLib.Internal.NonNullableUtf8StringOwnedHandle.Create(password);
    var resultPasswordStoreSync = Secret.Internal.Functions.PasswordStoreSync((Secret.Internal.SchemaHandle?) schema?.Handle ?? Secret.Internal.SchemaUnownedHandle.NullHandle, attributes.Handle, collectionNative, labelNative, passwordNative, cancellable?.Handle.DangerousGetHandle() ?? IntPtr.Zero, out GLib.Internal.ErrorOwnedHandle error);
if(!error.IsInvalid)
    throw new GLib.GException(error);
    
    
    return resultPasswordStoreSync;
}


public static void PasswordWipe(string? password)
{
    using var passwordNative = GLib.Internal.NullableUtf8StringOwnedHandle.Create(password);
    Secret.Internal.Functions.PasswordWipe(passwordNative);

    
    
    
}
}