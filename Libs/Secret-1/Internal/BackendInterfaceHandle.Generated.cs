using System;
using GObject;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Secret.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY


public abstract class BackendInterfaceHandle : SafeHandle
{    
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected BackendInterfaceHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }

    public GObject.Internal.TypeInterfaceData GetParentIface()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).ParentIface;
}

public BackendInterfaceData.EnsureForFlagsCallback GetEnsureForFlags()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).EnsureForFlags;
}

public BackendInterfaceData.EnsureForFlagsFinishCallback GetEnsureForFlagsFinish()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).EnsureForFlagsFinish;
}

public BackendInterfaceData.StoreCallback GetStore()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).Store;
}

public BackendInterfaceData.StoreFinishCallback GetStoreFinish()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).StoreFinish;
}

public BackendInterfaceData.LookupCallback GetLookup()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).Lookup;
}

public BackendInterfaceData.LookupFinishCallback GetLookupFinish()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).LookupFinish;
}

public BackendInterfaceData.ClearCallback GetClear()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).Clear;
}

public BackendInterfaceData.ClearFinishCallback GetClearFinish()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).ClearFinish;
}

public BackendInterfaceData.SearchCallback GetSearch()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).Search;
}

public BackendInterfaceData.SearchFinishCallback GetSearchFinish()
{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException("Handle is closed or invalid");

    return Marshal.PtrToStructure<BackendInterfaceData>(handle).SearchFinish;
}


    public bool Equals(BackendInterfaceHandle? other)
    {
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }

    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is BackendInterfaceHandle other && Equals(other);
    }

    public override int GetHashCode()
    {
        return handle.GetHashCode();
    }
}

public class BackendInterfaceUnownedHandle : BackendInterfaceHandle
{
    private static BackendInterfaceUnownedHandle? nullHandle;
    public static BackendInterfaceUnownedHandle NullHandle => nullHandle ??= new BackendInterfaceUnownedHandle();

    /// <summary>
    /// Creates a new instance of BackendInterfaceUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal BackendInterfaceUnownedHandle() : base(false) { }

    /// <summary>
    /// Creates a new instance of BackendInterfaceOwnedHandle. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public BackendInterfaceUnownedHandle(IntPtr ptr) : base(false)
    {
        SetHandle(ptr);
    }

    public BackendInterfaceOwnedHandle Copy()
    {
        var size = Marshal.SizeOf<BackendInterfaceData>();
        var ptr = GLib.Functions.Memdup2(handle,(nuint) size);
            
        return new BackendInterfaceOwnedHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public class BackendInterfaceOwnedHandle : BackendInterfaceHandle
{
    /// <summary>
    /// Creates a new instance of BackendInterfaceOwnedHandle. Used automatically by PInvoke.
    /// </summary>
    internal BackendInterfaceOwnedHandle() : base(true) { }

    /// <summary>
    /// Creates a new instance of BackendInterfaceOwnedHandle. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public BackendInterfaceOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

    /// <summary>
    /// Creates a new owned Handle
    /// </summary>
    public static BackendInterfaceOwnedHandle Create()
    {
        var size = Marshal.SizeOf<BackendInterfaceData>();
        var ptr = GLib.Functions.Malloc((nuint)size);
       
        var str = new BackendInterfaceData();
        Marshal.StructureToPtr(str, ptr, false);
            
        return new BackendInterfaceOwnedHandle(ptr);
    }

    public unsafe void CopyTo(IntPtr ptr)
    {
        var data = Marshal.PtrToStructure<BackendInterfaceData>(handle);
        Marshal.StructureToPtr(data, ptr, false);
    }

    public BackendInterfaceUnownedHandle UnownedCopy()
    {
        var size = Marshal.SizeOf<BackendInterfaceData>();
        var ptr = GLib.Functions.Memdup2(handle,(nuint) size);
            
        return new BackendInterfaceUnownedHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        GLib.Functions.Free(handle);
        return true;
    }
}

public abstract class BackendInterfaceArrayHandle : SafeHandle
{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected BackendInterfaceArrayHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }
}

public class BackendInterfaceArrayUnownedHandle : BackendInterfaceArrayHandle
{
    private static BackendInterfaceArrayUnownedHandle? nullHandle;
    public static BackendInterfaceArrayUnownedHandle NullHandle => nullHandle ??= new BackendInterfaceArrayUnownedHandle();
    
    private int length;

    /// <summary>
    /// Creates a new instance of BackendInterfaceArrayUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal BackendInterfaceArrayUnownedHandle() : base(false) { }
    
    public BackendInterfaceArrayUnownedHandle(IntPtr ptr, int length) : base(false)
    {
        this.length = length;
        SetHandle(ptr);
    }

    public Secret.BackendInterface[] ToArray(int length)
    {
        return ToNullableArray(length) ?? throw new InvalidOperationException("Handle is invalid");
    }

    public Secret.BackendInterface[]? ToNullableArray(int length)
    {
        if (IsInvalid)
            return null;
        
        var data = new Secret.BackendInterface[length];
        var currentHandle = handle;
        for(int i = 0; i < length; i++)
        {
            var ownedHandle = new Secret.Internal.BackendInterfaceUnownedHandle(currentHandle).Copy();
            data[i] = new Secret.BackendInterface(ownedHandle);
            currentHandle += Marshal.SizeOf<Secret.Internal.BackendInterfaceData>();
        }

        return data;
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public class BackendInterfaceArrayOwnedHandle : BackendInterfaceArrayHandle
{
    
    //This has no constructor without parameters as we can't supply a length to an array via pinvoke.
    //The length would need to be set manually and the instance be freed via glib.

    private BackendInterfaceArrayOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

    public static BackendInterfaceArrayOwnedHandle Create(Secret.BackendInterface[] data)
    {
        var size = Marshal.SizeOf<Secret.Internal.BackendInterfaceData>();
        var ptr = Marshal.AllocHGlobal(size * data.Length);
        var current = ptr;
        for (int i = 0; i < data.Length; i++)
        {
            var structure = Marshal.PtrToStructure<Secret.Internal.BackendInterfaceData>(data[i].Handle.DangerousGetHandle());
            Marshal.StructureToPtr(structure, current, false);
            current += size;
        }
        
        return new BackendInterfaceArrayOwnedHandle(ptr);
    }
    
    protected override bool ReleaseHandle()
    {
        Marshal.FreeHGlobal(handle);
        return true;
    }
}