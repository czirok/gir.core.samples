using System;
using GObject;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Secret.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY


public abstract class ValueHandle : SafeHandle, IEquatable<ValueHandle>
{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected ValueHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }

    

    public ValueOwnedHandle OwnedCopy()
    {
        var ptr = GObject.Internal.Functions.BoxedCopy(Secret.Internal.Value.GetGType(), handle);
        return new ValueOwnedHandle(ptr);
    }

    public ValueUnownedHandle UnownedCopy()
    {
        var ptr = GObject.Internal.Functions.BoxedCopy(Secret.Internal.Value.GetGType(), handle);
        return new ValueUnownedHandle(ptr);
    }

    public bool Equals(ValueHandle? other)
    {
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }

    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is ValueHandle other && Equals(other);
    }

    public override int GetHashCode()
    {
        return handle.GetHashCode();
    }
}

public class ValueUnownedHandle : ValueHandle
{
    private static ValueUnownedHandle? nullHandle;
    public static ValueUnownedHandle NullHandle => nullHandle ??= new ValueUnownedHandle();

    /// <summary>
    /// Creates a new instance of ValueUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ValueUnownedHandle() : base(false) { }

    /// <summary>
    /// Creates a new instance of ValueOwnedHandle. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public ValueUnownedHandle(IntPtr ptr) : base(false)
    {
        SetHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public partial class ValueOwnedHandle : ValueHandle
{
    /// <summary>
    /// Creates a new instance of ValueOwnedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ValueOwnedHandle() : base(true) { }

    /// <summary>
    /// Creates a new instance of ValueOwnedHandle. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public ValueOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

   

    /// <summary>
    /// Create a ValueOwnedHandle from a pointer that is assumed unowned. To do so a
    /// boxed copy is created of the given pointer to be used as the handle.
    /// </summary>
    /// <param name="ptr">A pointer to a Value which is not owned by the runtime.</param>
    /// <returns>A ValueOwnedHandle</returns>
    public static ValueOwnedHandle FromUnowned(IntPtr ptr)
    {
        var ownedPtr = GObject.Internal.Functions.BoxedCopy(Secret.Internal.Value.GetGType(), ptr);
        return new ValueOwnedHandle(ownedPtr);
    }

    internal void SetMemoryPressure()
    {
        AddMemoryPressure();
    }

    partial void AddMemoryPressure();
    partial void RemoveMemoryPressure();

    protected override bool ReleaseHandle()
    {
        RemoveMemoryPressure();
        GObject.Internal.Functions.BoxedFree(Secret.Internal.Value.GetGType(), handle);
        return true;
    }
}