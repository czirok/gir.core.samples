using System;
using GObject;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Secret.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY


public abstract class ItemPrivateHandle : SafeHandle
{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected ItemPrivateHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }

    public ItemPrivateOwnedHandle OwnedCopy() => throw new NotSupportedException("Can't create a copy of this handle");
    public ItemPrivateUnownedHandle UnownedCopy() => throw new NotSupportedException("Can't create a copy of this handle");

    public bool Equals(ItemPrivateHandle? other)
    {
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }

    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is ItemPrivateHandle other && Equals(other);
    }

    public override int GetHashCode()
    {
        return handle.GetHashCode();
    }
}

public class ItemPrivateUnownedHandle : ItemPrivateHandle
{
    private static ItemPrivateUnownedHandle? nullHandle;
    public static ItemPrivateUnownedHandle NullHandle => nullHandle ??= new ItemPrivateUnownedHandle();

    /// <summary>
    /// Creates a new instance of ItemPrivateUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ItemPrivateUnownedHandle() : base(false) { }

    /// <summary>
    /// Creates a new instance of ItemPrivateUnownedHandle. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public ItemPrivateUnownedHandle(IntPtr ptr) : base(false)
    {
        SetHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public class ItemPrivateOwnedHandle : ItemPrivateHandle
{
    /// <summary>
    /// Creates a new instance of ItemPrivateOwnedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ItemPrivateOwnedHandle() : base(true) { }

    /// <summary>
    /// Creates a new instance of ItemPrivateOwnedHandle. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public ItemPrivateOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

    /// <summary>
    /// Create a ItemPrivateOwnedHandle from a pointer that is assumed unowned.
    /// </summary>
    /// <param name="ptr">A pointer to a ItemPrivate which is not owned by the runtime.</param>
    /// <returns>A ItemPrivateOwnedHandle</returns>
    public static ItemPrivateOwnedHandle FromUnowned(IntPtr ptr) => throw new NotSupportedException("Can't create a copy of this handle");

    protected override bool ReleaseHandle() => throw new NotSupportedException("Can't free this handle");
}