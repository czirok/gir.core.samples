using System;
using GObject;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Secret.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY


public abstract class CollectionPrivateHandle : SafeHandle
{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected CollectionPrivateHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }

    public CollectionPrivateOwnedHandle OwnedCopy() => throw new NotSupportedException("Can't create a copy of this handle");
    public CollectionPrivateUnownedHandle UnownedCopy() => throw new NotSupportedException("Can't create a copy of this handle");

    public bool Equals(CollectionPrivateHandle? other)
    {
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }

    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is CollectionPrivateHandle other && Equals(other);
    }

    public override int GetHashCode()
    {
        return handle.GetHashCode();
    }
}

public class CollectionPrivateUnownedHandle : CollectionPrivateHandle
{
    private static CollectionPrivateUnownedHandle? nullHandle;
    public static CollectionPrivateUnownedHandle NullHandle => nullHandle ??= new CollectionPrivateUnownedHandle();

    /// <summary>
    /// Creates a new instance of CollectionPrivateUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal CollectionPrivateUnownedHandle() : base(false) { }

    /// <summary>
    /// Creates a new instance of CollectionPrivateUnownedHandle. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public CollectionPrivateUnownedHandle(IntPtr ptr) : base(false)
    {
        SetHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public class CollectionPrivateOwnedHandle : CollectionPrivateHandle
{
    /// <summary>
    /// Creates a new instance of CollectionPrivateOwnedHandle. Used automatically by PInvoke.
    /// </summary>
    internal CollectionPrivateOwnedHandle() : base(true) { }

    /// <summary>
    /// Creates a new instance of CollectionPrivateOwnedHandle. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public CollectionPrivateOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

    /// <summary>
    /// Create a CollectionPrivateOwnedHandle from a pointer that is assumed unowned.
    /// </summary>
    /// <param name="ptr">A pointer to a CollectionPrivate which is not owned by the runtime.</param>
    /// <returns>A CollectionPrivateOwnedHandle</returns>
    public static CollectionPrivateOwnedHandle FromUnowned(IntPtr ptr) => throw new NotSupportedException("Can't create a copy of this handle");

    protected override bool ReleaseHandle() => throw new NotSupportedException("Can't free this handle");
}