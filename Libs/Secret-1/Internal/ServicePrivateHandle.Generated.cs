using System;
using GObject;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace Secret.Internal;

// AUTOGENERATED FILE - DO NOT MODIFY


public abstract class ServicePrivateHandle : SafeHandle
{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected ServicePrivateHandle(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { }

    public ServicePrivateOwnedHandle OwnedCopy() => throw new NotSupportedException("Can't create a copy of this handle");
    public ServicePrivateUnownedHandle UnownedCopy() => throw new NotSupportedException("Can't create a copy of this handle");

    public bool Equals(ServicePrivateHandle? other)
    {
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }

    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is ServicePrivateHandle other && Equals(other);
    }

    public override int GetHashCode()
    {
        return handle.GetHashCode();
    }
}

public class ServicePrivateUnownedHandle : ServicePrivateHandle
{
    private static ServicePrivateUnownedHandle? nullHandle;
    public static ServicePrivateUnownedHandle NullHandle => nullHandle ??= new ServicePrivateUnownedHandle();

    /// <summary>
    /// Creates a new instance of ServicePrivateUnownedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ServicePrivateUnownedHandle() : base(false) { }

    /// <summary>
    /// Creates a new instance of ServicePrivateUnownedHandle. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public ServicePrivateUnownedHandle(IntPtr ptr) : base(false)
    {
        SetHandle(ptr);
    }

    protected override bool ReleaseHandle()
    {
        throw new System.Exception("UnownedHandle must not be freed");
    }
}

public class ServicePrivateOwnedHandle : ServicePrivateHandle
{
    /// <summary>
    /// Creates a new instance of ServicePrivateOwnedHandle. Used automatically by PInvoke.
    /// </summary>
    internal ServicePrivateOwnedHandle() : base(true) { }

    /// <summary>
    /// Creates a new instance of ServicePrivateOwnedHandle. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public ServicePrivateOwnedHandle(IntPtr ptr) : base(true)
    {
        SetHandle(ptr);
    }

    /// <summary>
    /// Create a ServicePrivateOwnedHandle from a pointer that is assumed unowned.
    /// </summary>
    /// <param name="ptr">A pointer to a ServicePrivate which is not owned by the runtime.</param>
    /// <returns>A ServicePrivateOwnedHandle</returns>
    public static ServicePrivateOwnedHandle FromUnowned(IntPtr ptr) => throw new NotSupportedException("Can't create a copy of this handle");

    protected override bool ReleaseHandle() => throw new NotSupportedException("Can't free this handle");
}